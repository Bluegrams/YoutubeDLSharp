import sys
import re
import json
import html

# configuration

TYPE_MAP = {
    "LimitRate": "long?",
    "Retries": "int?",
    "FragmentRetries": "int?",
    "BufferSize": "long?",
    "HttpChunkSize": "long?",
    "AutonumberStart": "int?",
    "SocketTimeout": "int?",
    "AudioFormat":  "AudioConversionFormat",
    "AudioQuality": "byte?",
    "RecodeVideo":  "VideoRecodeFormat",
    "MergeOutputFormat": "DownloadMergeFormat",
    "PlaylistStart": "int?",
    "PlaylistEnd": "int?",
    "MaxDownloads": "int?",
    "Date": "DateTime",
    "DateBefore": "DateTime",
    "DateAfter": "DateTime",
    "MinViews": "long?",
    "MaxViews": "long?",
    "AgeLimit": "byte?",
    "SleepInterval": "int?",
    "MaxSleepInterval":  "int?"
}
TRANSLATE_MAP = {
    "Twofactor": "TwoFactor",
    "RmCacheDir": "RemoveCacheDir",
    "ForceIpv4": "ForceIPv4",
    "ForceIpv6": "ForceIPv6",
    "Datebefore": "DateBefore",
    "Dateafter": "DateAfter",
}

CODE_TEMPLATE = [
    "// <auto-generated>",
    "// This code was partially generated by a tool.",
    "// </auto-generated>",
    "",
    "using System;",
    "",
    "namespace YoutubeDLSharp.Options",
    "{",
    "    public partial class OptionSet",
    "    {",
    "    }",
    "}",
    ""
]
INSERT_LINE = 10
INDENT = 8
option_attr_string = "private Option<{0}> {1} = new Option<{0}>(\"{2}\");"
option_prop_string = "public {0} {2} {{ get => {1}.Value; set => {1}.Value = value; }}"

IN_FILE = sys.argv[1]
IN_INDENT = 37
EMPTY_LINE = "\n\n"


# helper methods

def prepare_name(name):
    name = name.replace("-", " ").replace("/", "and").title().replace(" ", "")
    if name in TRANSLATE_MAP:
        name = TRANSLATE_MAP[name]
    return name

def infer_type(name, s):
    if len(s.split()) == 1:
        return "bool"
    elif name in TYPE_MAP.keys():
        return TYPE_MAP[name]
    else:
        return "string"

def build_attr(ctype, name, literals):
    attr_name = name[:1].lower() + name[1:]
    return INDENT*" " + option_attr_string.format(ctype, attr_name, "\", \"".join(literals))

def build_summary(descr_lines):
    prop_list = [
        INDENT*" " + "/// <summary>",
        INDENT*" " + "/// </summary>",
    ]
    for i, line in enumerate(descr_lines):
        prop_list.insert(1+i, INDENT*" " + "/// " + html.escape(line.strip()))
    return prop_list

def build_prop(ctype, name, descr_lines=None):
    attr_name = name[:1].lower() + name[1:]
    prop_list = []
    if descr_lines:
        prop_list.extend(build_summary(descr_lines))
    prop_list.append(INDENT*" " + option_prop_string.format(ctype, attr_name, name))
    return prop_list

# analyze file

def convert_to_file(lines, name):
    file = "OptionSet.{}.cs".format(name)
    items = []
    current_item = []
    current_descr = []
    for line in lines:
        if line.startswith(" "*(IN_INDENT)):
            current_descr.append(line[IN_INDENT:]) 
        elif line.strip().startswith("-"):
            if current_item:
                items.append((current_item, current_descr))
            current_item = [s.strip() for s in line[:IN_INDENT].split(',')]
            current_descr = [line[IN_INDENT:]]    
    items.append((current_item, current_descr))
    print("%s : Found %d items." % (name, len(items)))
    # build code
    attrs = []
    props = []
    for item in items:
        literals = [s.split()[0] for s in item[0]]
        name = prepare_name(literals[-1])
        ctype = infer_type(name, item[0][-1])
        attrs.append(build_attr(ctype, name, literals))
        props.extend(build_prop(ctype, name, item[1]))
    # insert code
    code = list(CODE_TEMPLATE)
    code[INSERT_LINE:INSERT_LINE] = attrs + [""] + props
    # write to file
    with open(file, 'wb') as f:
        f.write("\r\n".join(code).encode('utf-8-sig'))

# read file

with open(IN_FILE, 'r') as f:
    all_text = f.read()
    # forward-compatibility w. yt-dlp
    all_text = re.sub(r"\n\s+Adobe Pass Options:", "", all_text)
    all_text = all_text.split(EMPTY_LINE)[1:]
for par in all_text:
    lines = [line for line in par.splitlines() if line.startswith(" ")]
    name = re.sub("(Options)?:", "", prepare_name(lines[0].strip()))
    convert_to_file(lines[1:], name)
