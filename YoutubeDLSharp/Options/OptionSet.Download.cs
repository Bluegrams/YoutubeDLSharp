// <auto-generated>
// This code was partially generated by a tool.
// </auto-generated>

using System;

namespace YoutubeDLSharp.Options
{
    public partial class OptionSet
    {
        private Option<int?> concurrentFragments = new Option<int?>("-N", "--concurrent-fragments");
        private Option<long?> limitRate = new Option<long?>("-r", "--limit-rate");
        private Option<long?> throttledRate = new Option<long?>("--throttled-rate");
        private Option<int?> retries = new Option<int?>("-R", "--retries");
        private Option<int?> fileAccessRetries = new Option<int?>("--file-access-retries");
        private Option<int?> fragmentRetries = new Option<int?>("--fragment-retries");
        private MultiOption<string> retrySleep = new MultiOption<string>("--retry-sleep");
        private Option<bool> skipUnavailableFragments = new Option<bool>("--skip-unavailable-fragments");
        private Option<bool> abortOnUnavailableFragment = new Option<bool>("--abort-on-unavailable-fragment");
        private Option<bool> keepFragments = new Option<bool>("--keep-fragments");
        private Option<bool> noKeepFragments = new Option<bool>("--no-keep-fragments");
        private Option<long?> bufferSize = new Option<long?>("--buffer-size");
        private Option<bool> resizeBuffer = new Option<bool>("--resize-buffer");
        private Option<bool> noResizeBuffer = new Option<bool>("--no-resize-buffer");
        private Option<long?> httpChunkSize = new Option<long?>("--http-chunk-size");
        private Option<bool> playlistRandom = new Option<bool>("--playlist-random");
        private Option<bool> lazyPlaylist = new Option<bool>("--lazy-playlist");
        private Option<bool> noLazyPlaylist = new Option<bool>("--no-lazy-playlist");
        private Option<bool> xattrSetFilesize = new Option<bool>("--xattr-set-filesize");
        private Option<bool> hlsUseMpegts = new Option<bool>("--hls-use-mpegts");
        private Option<bool> noHlsUseMpegts = new Option<bool>("--no-hls-use-mpegts");
        private MultiOption<string> downloadSections = new MultiOption<string>("--download-sections");
        private MultiOption<string> downloader = new MultiOption<string>("--downloader", "--external-downloader");
        private MultiOption<string> downloaderArgs = new MultiOption<string>("--downloader-args", "--external-downloader-args");

        /// <summary>
        /// Number of fragments of a dash/hlsnative
        /// video that should be downloaded concurrently
        /// (default is 1)
        /// </summary>
        public int? ConcurrentFragments { get => concurrentFragments.Value; set => concurrentFragments.Value = value; }
        /// <summary>
        /// Maximum download rate in bytes per second,
        /// e.g. 50K or 4.2M
        /// </summary>
        public long? LimitRate { get => limitRate.Value; set => limitRate.Value = value; }
        /// <summary>
        /// Minimum download rate in bytes per second
        /// below which throttling is assumed and the
        /// video data is re-extracted, e.g. 100K
        /// </summary>
        public long? ThrottledRate { get => throttledRate.Value; set => throttledRate.Value = value; }
        /// <summary>
        /// Number of retries (default is 10), or
        /// &quot;infinite&quot;
        /// </summary>
        public int? Retries { get => retries.Value; set => retries.Value = value; }
        /// <summary>
        /// Number of times to retry on file access
        /// error (default is 3), or &quot;infinite&quot;
        /// </summary>
        public int? FileAccessRetries { get => fileAccessRetries.Value; set => fileAccessRetries.Value = value; }
        /// <summary>
        /// Number of retries for a fragment (default is
        /// 10), or &quot;infinite&quot; (DASH, hlsnative and ISM)
        /// </summary>
        public int? FragmentRetries { get => fragmentRetries.Value; set => fragmentRetries.Value = value; }
        /// <summary>
        /// Time to sleep between retries in seconds
        /// (optionally) prefixed by the type of retry
        /// (http (default), fragment, file_access,
        /// extractor) to apply the sleep to. EXPR can
        /// be a number, linear=START[:END[:STEP=1]] or
        /// exp=START[:END[:BASE=2]]. This option can be
        /// used multiple times to set the sleep for the
        /// different retry types, e.g. --retry-sleep
        /// linear=1::2 --retry-sleep fragment:exp=1:20
        /// </summary>
        public MultiValue<string> RetrySleep { get => retrySleep.Value; set => retrySleep.Value = value; }
        /// <summary>
        /// Skip unavailable fragments for DASH,
        /// hlsnative and ISM downloads (default)
        /// (Alias: --no-abort-on-unavailable-fragment)
        /// </summary>
        public bool SkipUnavailableFragments { get => skipUnavailableFragments.Value; set => skipUnavailableFragments.Value = value; }
        /// <summary>
        /// 
        /// Abort download if a fragment is unavailable
        /// (Alias: --no-skip-unavailable-fragments)
        /// </summary>
        public bool AbortOnUnavailableFragment { get => abortOnUnavailableFragment.Value; set => abortOnUnavailableFragment.Value = value; }
        /// <summary>
        /// Keep downloaded fragments on disk after
        /// downloading is finished
        /// </summary>
        public bool KeepFragments { get => keepFragments.Value; set => keepFragments.Value = value; }
        /// <summary>
        /// Delete downloaded fragments after
        /// downloading is finished (default)
        /// </summary>
        public bool NoKeepFragments { get => noKeepFragments.Value; set => noKeepFragments.Value = value; }
        /// <summary>
        /// Size of download buffer, e.g. 1024 or 16K
        /// (default is 1024)
        /// </summary>
        public long? BufferSize { get => bufferSize.Value; set => bufferSize.Value = value; }
        /// <summary>
        /// The buffer size is automatically resized
        /// from an initial value of --buffer-size
        /// (default)
        /// </summary>
        public bool ResizeBuffer { get => resizeBuffer.Value; set => resizeBuffer.Value = value; }
        /// <summary>
        /// Do not automatically adjust the buffer size
        /// </summary>
        public bool NoResizeBuffer { get => noResizeBuffer.Value; set => noResizeBuffer.Value = value; }
        /// <summary>
        /// Size of a chunk for chunk-based HTTP
        /// downloading, e.g. 10485760 or 10M (default
        /// is disabled). May be useful for bypassing
        /// bandwidth throttling imposed by a webserver
        /// (experimental)
        /// </summary>
        public long? HttpChunkSize { get => httpChunkSize.Value; set => httpChunkSize.Value = value; }
        /// <summary>
        /// Download playlist videos in random order
        /// </summary>
        public bool PlaylistRandom { get => playlistRandom.Value; set => playlistRandom.Value = value; }
        /// <summary>
        /// Process entries in the playlist as they are
        /// received. This disables n_entries,
        /// --playlist-random and --playlist-reverse
        /// </summary>
        public bool LazyPlaylist { get => lazyPlaylist.Value; set => lazyPlaylist.Value = value; }
        /// <summary>
        /// Process videos in the playlist only after
        /// the entire playlist is parsed (default)
        /// </summary>
        public bool NoLazyPlaylist { get => noLazyPlaylist.Value; set => noLazyPlaylist.Value = value; }
        /// <summary>
        /// Set file xattribute ytdl.filesize with
        /// expected file size
        /// </summary>
        public bool XattrSetFilesize { get => xattrSetFilesize.Value; set => xattrSetFilesize.Value = value; }
        /// <summary>
        /// Use the mpegts container for HLS videos;
        /// allowing some players to play the video
        /// while downloading, and reducing the chance
        /// of file corruption if download is
        /// interrupted. This is enabled by default for
        /// live streams
        /// </summary>
        public bool HlsUseMpegts { get => hlsUseMpegts.Value; set => hlsUseMpegts.Value = value; }
        /// <summary>
        /// Do not use the mpegts container for HLS
        /// videos. This is default when not downloading
        /// live streams
        /// </summary>
        public bool NoHlsUseMpegts { get => noHlsUseMpegts.Value; set => noHlsUseMpegts.Value = value; }
        /// <summary>
        /// Download only chapters whose title matches
        /// the given regular expression. Time ranges
        /// prefixed by a &quot;*&quot; can also be used in place
        /// of chapters to download the specified range.
        /// Needs ffmpeg. This option can be used
        /// multiple times to download multiple
        /// sections, e.g. --download-sections
        /// &quot;*10:15-inf&quot; --download-sections &quot;intro&quot;
        /// </summary>
        public MultiValue<string> DownloadSections { get => downloadSections.Value; set => downloadSections.Value = value; }
        /// <summary>
        /// Name or path of the external downloader to
        /// use (optionally) prefixed by the protocols
        /// (http, ftp, m3u8, dash, rstp, rtmp, mms) to
        /// use it for. Currently supports native,
        /// aria2c, avconv, axel, curl, ffmpeg, httpie,
        /// wget. You can use this option multiple times
        /// to set different downloaders for different
        /// protocols. E.g. --downloader aria2c
        /// --downloader &quot;dash,m3u8:native&quot; will use
        /// aria2c for http/ftp downloads, and the
        /// native downloader for dash/m3u8 downloads
        /// (Alias: --external-downloader)
        /// </summary>
        public MultiValue<string> Downloader { get => downloader.Value; set => downloader.Value = value; }
        /// <summary>
        /// Give these arguments to the external
        /// downloader. Specify the downloader name and
        /// the arguments separated by a colon &quot;:&quot;. For
        /// ffmpeg, arguments can be passed to different
        /// positions using the same syntax as
        /// --postprocessor-args. You can use this
        /// option multiple times to give different
        /// arguments to different downloaders (Alias:
        /// --external-downloader-args)
        /// </summary>
        public MultiValue<string> DownloaderArgs { get => downloaderArgs.Value; set => downloaderArgs.Value = value; }
    }
}
